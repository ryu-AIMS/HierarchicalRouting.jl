# HierarchicalRouting

HierarchicalRouting is a Julia package that implements metaheuristics to generate
near‐optimal routing solutions for a fleet of coordinated vessels, including one mothership
and a given number of satellite vessels (tenders).
The package supports planning for scenarios with multiple multiple clusters of target sites
and environmental constraints (exclusion zones).

## Setup

### Installation
To install the package, use the Julia package manager in the REPL:

```julia
] add HierarchicalRouting
```

You may check the installed version with:

```julia
] st HierarchicalRouting
```

### Parameters
#### Problem parameters
All problem parameters (data paths, vessel capacities, clustering tolerance, etc.) must be
provided by the user directly as arguments to `load_problem()` .

The package requires the following data files:
- **Target scenario**: A GeoJSON file containing the target sites to be visited.
- **Subset**: A geopackage file containing polygons to define the subset of target scenarios
    to be considered in the problem instance.
- **Environmental data**: A TIF file containing the data (e.g., bathymetry) which informs
    the exclusion zones, limiting access, for the mothership and tenders.
- **Wave disturbance**: A GeoJSON file containing the wave disturbance data, used to
    generate weather disturbance events.
- **Depot**: A tuple representing the depot location, in the form (lon, lat) which is the
    used as the coincident start and finish point for the deployment plan.
- **Draft**: The draft of vessels (in metres), given as a negative value, indicating the
    clearance depth of the vessel below the surface.
    - **Mothership draft**: The draft of the mothership.
    - **Tender draft**: The draft of the tenders.
- **Weighting**: The weighting factor for the mothership and tenders, as a multiplier of
    distance travelled to quantify cost.
    - **Mothership weighting**: The weighting factor for the mothership.
    - **Tender weighting**: The weighting factor for the tenders.
- **Number of tenders**: The number of tenders available to use for deployment.
- **Tender capacity**: The capacity of the tenders, determining the maximum number of targets
    that can be visited/deployed by a tender in a single trip.
- **Target subset path**: The path to save the target subset raster. Default is "".

#### Solution parameters
The solution parameters are defined in the `initial_solution()` and `improve_solution()`
functions.

- **Initial solution**: The initial solution to be improved. This is generated by the
    `initial_solution()` function.
- **Number of clusters**: The number of clusters to be generated in the initial solution.
- **Optimization function**: The optimization function to be used to improve the solution.
    Currently, this has to be:
    - `HierarchicalRouting.simulated_annealing`
but, other optimization functions may be added in the future.
- **Objective function**: The objective function to be used to evaluate the solution.
    Currently, this has to be:
    - `HierarchicalRouting.critical_path`
but, other objective functions may be added in the future.
- **Perturbation function**: The perturbation function to be used to generate a new solution
    from the current solution. Currently, this has to be:
    - `HierarchicalRouting.perturb_swap_solution`
- **Exclusion**: The exclusion zones to be used for the mothership and tenders. This is
    generated by the `load_problem()` function.
    - `Mothership`
    - `Tenders`

## Quickstart
Below is an example of how to load a problem, generate an initial solution, and improve the
solution.

```julia
using HierarchicalRouting

target_path = "<PATH/TO/TARGET_SCENARIO_GEOJSON>"
subset_path = "<PATH/TO/TARGET_SUBSET_GPKG>"
env_data_path = "<PATH/TO/BATHYMETRY_TIF>"
env_disturbance_path = "<PATH/TO/WAVE_DISTURBANCE_GEOJSON>"

# Load the problem configuration
problem = load_problem(
    target_path,
    subset_path,
    env_data_path,
    env_disturbance_path,
    (146.175, -16.84),                                              # depot
    -10.0,                                                          # draft_ms
    -5.0,                                                           # draft_t
    5.0,                                                            # weight_ms
    2.0,                                                            # weight_t
    3,                                                              # n_tenders
    2;                                                              # t_cap
);

# Generate an initial solution
solution_init = initial_solution(
    problem,                                                        # problem
    5;                                                              # num_clusters
);

# Improve solution using simulated annealing
solution_best, z_best = improve_solution(
    solution_init,                                                  # solution_init
    HierarchicalRouting.simulated_annealing,                        # opt_function
    HierarchicalRouting.critical_path,                              # objective_function
    HierarchicalRouting.perturb_swap_solution,                      # perturb_function
    problem.mothership.exclusion,                                   # exclusion
    problem.tenders.exclusion;                                      # exclusion
);
```

## Visualization

To visualize the routing solution, use GeoMakie and the `Plot` module.
Below are examples to create:
- one complete plot of final clusters, exclusions, and routes;
- a comparison of the full initial and full final (after optimization) solutions;
- a series of plots for each sequential routing plan pre-deployment, and at each(assuming 2)
disturbance event.

```julia
using GeoMakie

fig = Figure(size=(750, 880));
ax = Axis(fig[1, 1], xlabel="Longitude", ylabel="Latitude");
# Add exclusions for the mothership
HierarchicalRouting.Plot.exclusions!(ax, problem.mothership.exclusion, labels=true);
# Add exclusions for tenders
HierarchicalRouting.Plot.exclusions!(ax, problem.tenders.exclusion, labels=true);
# Add clustered points
HierarchicalRouting.Plot.clusters!(ax, clusters=solution_best.cluster_sets[end]);
# Add mothership routes
HierarchicalRouting.Plot.linestrings!(ax, solution_best.mothership_routes[end].route);
# Add tender routes
HierarchicalRouting.Plot.tenders!(ax, solution_best.tenders);
```
<img src="assets\initial_solution.png" alt="Initial solution plot" width="400" /></i>

```julia
using GeoMakie

fig = Figure(size=(1650, 600));
ax1, ax2 = Axis(fig[1, 1]), Axis(fig[1, 2]);
# Add exclusions for the tenders
HierarchicalRouting.Plot.exclusions!.(
    [ax1, ax2],
    [problem.tenders.exclusion],
    labels=false
);
# Add clustered points
HierarchicalRouting.Plot.clusters!(ax1, clusters=solution_init.cluster_sets[end]);
HierarchicalRouting.Plot.clusters!(ax2, clusters=solution_best.cluster_sets[end]);
# Add mothership routes
HierarchicalRouting.Plot.linestrings!.(
    [ax1, ax2],
    [
        solution_init.mothership_routes[end].route,
        solution_best.mothership_routes[end].route
    ]
);
# Add tender routes
HierarchicalRouting.Plot.tenders!.(
    [ax1, ax2],
    [solution_init.tenders, solution_best.tenders]
);
```
<img src="assets\optimized_solution.png" alt="Initial solution plot" width="800" /></i>

```julia
using GeoMakie

fig = Figure(size=(1650, 600))
ax1, ax2, ax3 =
    Axis(fig[1, 1], xlabel="Longitude", ylabel="Latitude"),
    Axis(fig[1, 2], xlabel="Longitude"),
    Axis(fig[1, 3], xlabel="Longitude");
# Add exclusions for tenders
HierarchicalRouting.Plot.exclusions!.(
    [ax1, ax2, ax3],
    [problem.tenders.exclusion],
    labels=false
);
# Add clustered points
HierarchicalRouting.Plot.clusters!(
    ax1,
    clusters=solution_best.cluster_sets[end],
    labels=true,
    centers=false,
    nodes= true,
    cluster_radius=0.025
);
HierarchicalRouting.Plot.clusters!(
    ax2,
    clusters=solution_best.cluster_sets[end],
    labels=true,
    centers=false,
    nodes= true,
    cluster_radius=0.025
);
HierarchicalRouting.Plot.clusters!(
    ax3,
    clusters=solution_best.cluster_sets[end],
    labels=true,
    centers=false,
    nodes= true,
    cluster_radius=0.025
);
# Add mothership routes
HierarchicalRouting.Plot.linestrings!.(
    [ax1, ax2, ax3],
    [solution_best.mothership_routes[1].route,
     solution_best.mothership_routes[2].route,
     solution_best.mothership_routes[3].route],
    labels=true,
    color=:black
);
# Add tender routes
HierarchicalRouting.Plot.tenders!(
    ax1,
    [solution_best.tenders[1]],
    5
);
HierarchicalRouting.Plot.tenders!(
    ax2,
    solution_best.tenders[1:3],
    5
);
HierarchicalRouting.Plot.tenders!(
    ax3,
    solution_best.tenders
);
```
<img src="assets\disturbance_solution.png" alt="Initial solution plot" height="300" width="800" /></i>

## Development setup

The steps below assume you are in the project root.

### Create a sandbox

Create a sandbox environment and install development dependencies.

```bash
mkdir sandbox
cd sandbox

julia project=.
(sandbox) julia> ]add Revise Infiltrate
(sandbox) julia> ]dev ..
```

### Run a development script

- Copy the quickstart to a file (e.g., `dev_routing.jl`) and save to the sandbox directory.
- Start the Julia REPL at project root:
(Assuming VS Code is configured to default to the sandbox environment)

```julia
;cd sandbox
include("dev_routing.jl")
```

## Project structure

The project structure is as follows:

```
HierarchicalRouting/
├───outputs             # Output files from analyses
├───src                 # Source code for package
│   ├───clustering      # Clustering utilities
│   ├───optimization    # Optimization heuristics
│   ├───plotting        # Visualizations
│   ├───problem         # Problem setup and initialization
│   ├───processing      # Data processing functions
│   └───routing         # Routing algorithms
└───test
```

## Solution structure

The solution (including problem) structure is as follows:

```
Problem
│
├── depot (Point{2, Float64})
├── targets (Targets)
├── mothership (Vessel)
└── tenders (Vessel)

Targets
│
├── points (DataFrame)
├── path (String)
└── disturbance_gdf (DataFrame)

Vessel
│
├── exclusion (DataFrame)
├── capacity (Int16)
├── number (Int8)
└── weighting (Float16)

MSTSolution
│
├── cluster_sets (Vector{Vector{Cluster}})
├── mothership_routes (Vector{MothershipSolution})
└── tenders (Vector{TenderSolution})

Cluster
│
├── id (Int64)
├── centroid (Point{2, Float64})
└── nodes (Vector{Point{2, Float64}})
 
MothershipSolution
│
├── cluster_sequence (DataFrame)
└── route (Route)

Route
│
├── nodes (Vector{Point{2, Float64}})
├── dist_matrix (Matrix{Float64})
└── line_strings (Vector{LineString{2, Float64}})
 
TenderSolution
│
├── id
├── start (Point{2, Float64})
├── finish (Point{2, Float64})
├── sorties (Vector{Route})
└── dist_matrix (Matrix{Float64})

```